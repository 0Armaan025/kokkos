diff --git a/core/src/Kokkos_Core_fwd.hpp b/core/src/Kokkos_Core_fwd.hpp
index b0d4d8a..d34e0bb 100644
--- a/core/src/Kokkos_Core_fwd.hpp
+++ b/core/src/Kokkos_Core_fwd.hpp
@@ -283,6 +283,10 @@ template< class FunctorType, class ExecPolicy, class ExecutionSapce =
           typename Impl::FunctorPolicyExecutionSpace< FunctorType, ExecPolicy >::execution_space
         > class ParallelScan;
 
+template< class FunctorType, class ExecPolicy, class ReturnType = InvalidType, class ExecutionSapce =
+          typename Impl::FunctorPolicyExecutionSpace< FunctorType, ExecPolicy >::execution_space
+        > class ParallelScan_;//VINH DANG -- Adding class ParallelScan_ for returning final scan result
+
 } // namespace Impl
 
 namespace Experimental {
diff --git a/core/src/Kokkos_Parallel.hpp b/core/src/Kokkos_Parallel.hpp
index 783cc7f..6826236 100644
--- a/core/src/Kokkos_Parallel.hpp
+++ b/core/src/Kokkos_Parallel.hpp
@@ -496,6 +496,96 @@ void parallel_scan( const std::string& str
   (void) str;
 }
 
+//VINH DANG -- Adding the following for returning final scan result
+template< class ExecutionPolicy , class FunctorType, class ReturnType >
+inline
+void parallel_scan( const ExecutionPolicy & policy
+                  , const FunctorType     & functor
+                  , const std::string& str = ""
+                  , typename Impl::enable_if< ! Impl::is_integral< ExecutionPolicy >::value >::type * = 0
+                  , ReturnType        & return_value=0
+                  )
+{
+#if defined(KOKKOS_ENABLE_PROFILING)
+  uint64_t kpID = 0;
+  if(Kokkos::Profiling::profileLibraryLoaded()) {
+    Kokkos::Impl::ParallelConstructName<FunctorType, typename ExecutionPolicy::work_tag> name(str);
+    Kokkos::Profiling::beginParallelScan(name.get(), 0, &kpID);
+  }
+#endif
+
+  Kokkos::Impl::shared_allocation_tracking_disable();
+  Impl::ParallelScan_< FunctorType , ExecutionPolicy, ReturnType > closure( functor, policy, return_value );
+  Kokkos::Impl::shared_allocation_tracking_enable();
+
+  closure.execute();
+
+#if defined(KOKKOS_ENABLE_PROFILING)
+  if(Kokkos::Profiling::profileLibraryLoaded()) {
+    Kokkos::Profiling::endParallelScan(kpID);
+  }
+#endif
+
+}
+
+template< class FunctorType, class ReturnType >
+inline
+void parallel_scan( const size_t        work_count
+                  , const FunctorType & functor
+                  , const std::string & str = ""
+                  , ReturnType        & return_value=0 )
+{
+  typedef typename
+    Kokkos::Impl::FunctorPolicyExecutionSpace< FunctorType , void >::execution_space
+      execution_space ;
+
+  typedef Kokkos::RangePolicy< execution_space > policy ;
+
+#if defined(KOKKOS_ENABLE_PROFILING)
+  uint64_t kpID = 0;
+  if(Kokkos::Profiling::profileLibraryLoaded()) {
+    Kokkos::Impl::ParallelConstructName<FunctorType, void> name(str);
+    Kokkos::Profiling::beginParallelScan(name.get(), 0, &kpID);
+  }
+#endif
+
+  Kokkos::Impl::shared_allocation_tracking_disable();
+  Impl::ParallelScan_< FunctorType, policy, ReturnType > closure( functor, policy(0,work_count), return_value );
+  Kokkos::Impl::shared_allocation_tracking_enable();
+
+  closure.execute();
+
+#if defined(KOKKOS_ENABLE_PROFILING)
+  if(Kokkos::Profiling::profileLibraryLoaded()) {
+    Kokkos::Profiling::endParallelScan(kpID);
+  }
+#endif
+
+}
+
+template< class ExecutionPolicy, class FunctorType, class ReturnType >
+inline
+void parallel_scan( const std::string& str
+                  , const ExecutionPolicy & policy
+                  , const FunctorType     & functor
+                  , ReturnType            & return_value)
+{
+  #if KOKKOS_ENABLE_DEBUG_PRINT_KERNEL_NAMES
+  Kokkos::fence();
+  std::cout << "KOKKOS_DEBUG Start parallel_scan kernel: " << str << std::endl;
+  #endif
+
+  ::Kokkos::parallel_scan(policy,functor,str,return_value);
+
+  #if KOKKOS_ENABLE_DEBUG_PRINT_KERNEL_NAMES
+  Kokkos::fence();
+  std::cout << "KOKKOS_DEBUG End parallel_scan kernel: " << str << std::endl;
+  #endif
+  (void) str;
+}
+//VINH DANG -- End of Adding
+
+
 } // namespace Kokkos
 
 //----------------------------------------------------------------------------
diff --git a/core/src/Kokkos_Serial.hpp b/core/src/Kokkos_Serial.hpp
index 065b5a0..a3caa7f 100644
--- a/core/src/Kokkos_Serial.hpp
+++ b/core/src/Kokkos_Serial.hpp
@@ -634,6 +634,90 @@ public:
     {}
 };
 
+/*--------------------------------------------------------------------------*/
+//VINH DANG -- Adding the following for returning final scan result
+template< class FunctorType , class ReturnType, class ... Traits >
+class ParallelScan_< FunctorType
+                  , Kokkos::RangePolicy< Traits ... >
+                  , ReturnType
+                  >
+{
+private:
+
+  typedef Kokkos::RangePolicy< Traits ... > Policy ;
+  typedef typename Policy::work_tag                                  WorkTag ;
+
+  typedef FunctorAnalysis< FunctorPatternInterface::SCAN , Policy , FunctorType > Analysis ;
+
+  typedef Kokkos::Impl::FunctorValueInit<   FunctorType , WorkTag >  ValueInit ;
+
+  typedef typename Analysis::pointer_type    pointer_type ;
+  typedef typename Analysis::reference_type  reference_type ;
+
+  const FunctorType   m_functor ;
+  const Policy        m_policy ;
+  ReturnType & m_returnvalue; ;
+
+  template< class TagType >
+  inline
+  typename std::enable_if< std::is_same< TagType , void >::value >::type
+  exec( reference_type update ) const
+    {
+      const typename Policy::member_type e = m_policy.end();
+      for ( typename Policy::member_type i = m_policy.begin() ; i < e ; ++i ) {
+        m_functor( i , update , true );
+      }
+    }
+
+  template< class TagType >
+  inline
+  typename std::enable_if< ! std::is_same< TagType , void >::value >::type
+  exec( reference_type update ) const
+    {
+      const TagType t{} ;
+      const typename Policy::member_type e = m_policy.end();
+      for ( typename Policy::member_type i = m_policy.begin() ; i < e ; ++i ) {
+        m_functor( t , i , update , true );
+      }
+    }
+
+public:
+
+  inline
+  void execute()
+    {
+      const size_t pool_reduce_size = Analysis::value_size( m_functor );
+      const size_t team_reduce_size  = 0 ; // Never shrinks
+      const size_t team_shared_size  = 0 ; // Never shrinks
+      const size_t thread_local_size = 0 ; // Never shrinks
+
+     serial_resize_thread_team_data( pool_reduce_size
+                                    , team_reduce_size
+                                    , team_shared_size
+                                    , thread_local_size );
+
+      HostThreadTeamData & data = *serial_get_thread_team_data();
+
+      reference_type update =
+        ValueInit::init( m_functor , pointer_type(data.pool_reduce_local()) );
+
+      this-> template exec< WorkTag >( update );
+
+      m_returnvalue = update;
+    }
+
+  inline
+  ParallelScan_( const FunctorType & arg_functor
+              , const Policy      & arg_policy
+              , ReturnType        & arg_returnvalue
+              )
+    : m_functor( arg_functor )
+    , m_policy(  arg_policy )
+    , m_returnvalue(  arg_returnvalue )
+    {}
+};
+//VINH DANG -- End of Adding
+
 } // namespace Impl
 } // namespace Kokkos
 
diff --git a/core/src/OpenMP/Kokkos_OpenMP_Parallel.hpp b/core/src/OpenMP/Kokkos_OpenMP_Parallel.hpp
index 2141610..d8f2e36 100644
--- a/core/src/OpenMP/Kokkos_OpenMP_Parallel.hpp
+++ b/core/src/OpenMP/Kokkos_OpenMP_Parallel.hpp
@@ -749,6 +749,146 @@ public:
   //----------------------------------------
 };
 
+//VINH DANG -- Adding the following for returning final scan result
+template< class FunctorType, class ReturnType, class ... Traits >
+class ParallelScan_< FunctorType
+                  , Kokkos::RangePolicy< Traits ... >
+                  , ReturnType
+                  , Kokkos::OpenMP
+                  >
+{
+private:
+
+  typedef Kokkos::RangePolicy< Traits ... > Policy ;
+
+  typedef FunctorAnalysis< FunctorPatternInterface::SCAN , Policy , FunctorType > Analysis ;
+
+  typedef typename Policy::work_tag     WorkTag ;
+  typedef typename Policy::WorkRange    WorkRange ;
+  typedef typename Policy::member_type  Member ;
+
+  typedef Kokkos::Impl::FunctorValueInit<   FunctorType, WorkTag > ValueInit ;
+  typedef Kokkos::Impl::FunctorValueJoin<   FunctorType, WorkTag > ValueJoin ;
+  typedef Kokkos::Impl::FunctorValueOps<    FunctorType, WorkTag > ValueOps ;
+
+  typedef typename Analysis::pointer_type    pointer_type ;
+  typedef typename Analysis::reference_type  reference_type ;
+
+        OpenMPExec   * m_instance;
+  const FunctorType    m_functor;
+  const Policy         m_policy;
+  ReturnType         & m_returnvalue;
+
+  template< class TagType >
+  inline static
+  typename std::enable_if< std::is_same< TagType , void >::value >::type
+  exec_range( const FunctorType & functor
+            , const Member ibeg , const Member iend
+            , reference_type update , const bool final )
+    {
+      for ( Member iwork = ibeg ; iwork < iend ; ++iwork ) {
+        functor( iwork , update , final );
+      }
+    }
+
+  template< class TagType >
+  inline static
+  typename std::enable_if< ! std::is_same< TagType , void >::value >::type
+  exec_range( const FunctorType & functor
+            , const Member ibeg , const Member iend
+            , reference_type update , const bool final )
+    {
+      const TagType t{} ;
+      for ( Member iwork = ibeg ; iwork < iend ; ++iwork ) {
+        functor( t , iwork , update , final );
+      }
+    }
+
+public:
+
+  inline
+  void execute() const
+    {
+      OpenMPExec::verify_is_master("Kokkos::OpenMP parallel_scan");
+
+      const int    value_count       = Analysis::value_count( m_functor );
+      const size_t pool_reduce_bytes = 2 * Analysis::value_size( m_functor );
+
+      m_instance->resize_thread_data( pool_reduce_bytes
+                                    , 0 // team_reduce_bytes
+                                    , 0 // team_shared_bytes
+                                    , 0 // thread_local_bytes
+                                    );
+
+      const int pool_size = OpenMP::thread_pool_size();
+      #pragma omp parallel num_threads(pool_size)
+      {
+        HostThreadTeamData & data = *(m_instance->get_thread_data());
+
+        const WorkRange range( m_policy, omp_get_thread_num(), omp_get_num_threads() );
+        reference_type update_sum =
+          ValueInit::init( m_functor , data.pool_reduce_local() );
+
+        ParallelScan_::template exec_range< WorkTag >
+          ( m_functor , range.begin() , range.end() , update_sum , false );
+
+        if ( data.pool_rendezvous() ) {
+
+          pointer_type ptr_prev = 0 ;
+
+          const int n = omp_get_num_threads();
+
+          for ( int i = 0 ; i < n ; ++i ) {
+
+            pointer_type ptr = (pointer_type)
+              data.pool_member(i)->pool_reduce_local();
+
+            if ( i ) {
+              for ( int j = 0 ; j < value_count ; ++j ) {
+                ptr[j+value_count] = ptr_prev[j+value_count] ;
+              }
+              ValueJoin::join( m_functor , ptr + value_count , ptr_prev );
+            }
+            else {
+              ValueInit::init( m_functor , ptr + value_count );
+            }
+
+            ptr_prev = ptr ;
+          }
+
+          data.pool_rendezvous_release();
+        }
+
+        reference_type update_base =
+          ValueOps::reference
+            ( ((pointer_type)data.pool_reduce_local()) + value_count );
+
+        ParallelScan_::template exec_range< WorkTag >
+          ( m_functor , range.begin() , range.end() , update_base , true );
+
+        if (omp_get_thread_num()==omp_get_num_threads()-1) {
+          m_returnvalue = update_base;
+        }
+      }
+
+    }
+
+  //----------------------------------------
+
+  inline
+  ParallelScan_( const FunctorType & arg_functor
+              , const Policy      & arg_policy
+              , ReturnType        & arg_returnvalue )
+    : m_instance( t_openmp_instance )
+    , m_functor( arg_functor )
+    , m_policy(  arg_policy )
+    , m_returnvalue(  arg_returnvalue )
+  {}
+
+  //----------------------------------------
+};
+//VINH DANG -- End of Adding
+
 } // namespace Impl
 } // namespace Kokkos
 
